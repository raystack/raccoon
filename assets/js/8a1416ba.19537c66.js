"use strict";(self.webpackChunkraccoon=self.webpackChunkraccoon||[]).push([[699],{5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>h});var a=n(6540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(n),g=o,h=u["".concat(l,".").concat(g)]||u[g]||d[g]||r;return n?a.createElement(h,s(s({ref:t},p),{},{components:n})):a.createElement(h,s({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=g;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:o,s[1]=i;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},6983:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var a=n(8168),o=(n(6540),n(5680));const r={toc_max_heading_level:4},s="Architecture",i={unversionedId:"concepts/architecture",id:"concepts/architecture",title:"Architecture",description:"Raccoon written in GO is a high throughput, low-latency service that provides an API to ingest streaming data from mobile apps, sites and publish it to message queues. Following message queues are currently supported:",source:"@site/docs/concepts/architecture.md",sourceDirName:"concepts",slug:"/concepts/architecture",permalink:"/raccoon/concepts/architecture",draft:!1,editUrl:"https://github.com/raystack/raccoon/edit/master/docs/docs/concepts/architecture.md",tags:[],version:"current",frontMatter:{toc_max_heading_level:4},sidebar:"docsSidebar",previous:{title:"Troubleshooting",permalink:"/raccoon/guides/troubleshooting"},next:{title:"Structure",permalink:"/raccoon/concepts/structure"}},l={},c=[{value:"System Design",id:"system-design",level:2},{value:"Connections",id:"connections",level:2},{value:"Websockets",id:"websockets",level:3},{value:"REST",id:"rest",level:3},{value:"gRPC",id:"grpc",level:3},{value:"Event Delivery Gurantee (at-least-once for most time)",id:"event-delivery-gurantee-at-least-once-for-most-time",level:3},{value:"Acknowledging events",id:"acknowledging-events",level:2},{value:"EVENT_ACK = 0",id:"event_ack--0",level:3},{value:"EVENT_ACK = 1",id:"event_ack--1",level:3},{value:"Supported Protocols and Data formats",id:"supported-protocols-and-data-formats",level:2},{value:"Request and Response Models",id:"request-and-response-models",level:2},{value:"Protobufs",id:"protobufs",level:3},{value:"JSON",id:"json",level:3},{value:"Event Distribution",id:"event-distribution",level:3},{value:"Event Deserialization",id:"event-deserialization",level:3},{value:"Channels",id:"channels",level:3},{value:"Keeping connections alive",id:"keeping-connections-alive",level:3},{value:"Components",id:"components",level:2},{value:"Producer",id:"producer",level:3},{value:"Apache Kafka",id:"apache-kafka",level:4},{value:"Google Cloud PubSub",id:"google-cloud-pubsub",level:4},{value:"AWS Kinesis Data Streams",id:"aws-kinesis-data-streams",level:4},{value:"Observability Stack",id:"observability-stack",level:3},{value:"StatD",id:"statd",level:4},{value:"Prometheus",id:"prometheus",level:4}],p={toc:c},u="wrapper";function d(e){let{components:t,...r}=e;return(0,o.yg)(u,(0,a.A)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"architecture"},"Architecture"),(0,o.yg)("p",null,"Raccoon written in ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/golang"},"GO")," is a high throughput, low-latency service that provides an API to ingest streaming data from mobile apps, sites and publish it to message queues. Following message queues are currently supported:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Apache Kafka"),(0,o.yg)("li",{parentName:"ul"},"Google Cloud PubSub "),(0,o.yg)("li",{parentName:"ul"},"AWS Kinesis Data Streams")),(0,o.yg)("p",null,"Raccoon supports websocket, REST and gRPC protocols for clients to send events. With websocket it provides long persistent connections, with no overhead of additional headers sizes as in http protocol. Racoon supports protocol buffers and JSON as serialization formats. Websocket and REST API support both whereas with gRPC only protocol buffers are supported. It provides an event type agnostic API that accepts a batch ","(","array",")"," of events in protobuf format. Refer ",(0,o.yg)("a",{parentName:"p",href:"/raccoon/guides/publishing#data-formatters"},"here")," for data definitions format that Raccoon accepts."),(0,o.yg)("p",null,"Raccoon was built with the primary purpose to source or collect user behaviour data in near-real time. User behaviour data is a stream of events that occur when users traverse through a mobile app or website. Raccoon powers analytics systems, big data pipelines and other disparate consumers by providing high volume, high throughput ingestion APIs consuming real time data. Raccoon\u2019s key architecture principle is a realization of an event agnostic backend ","(","accepts events of any type without the type awareness",")",". It is this capability that enables Raccoon to evolve into a strong player in the ingestion/collector ecosystem that has real time streaming/analytical needs."),(0,o.yg)("h2",{id:"system-design"},"System Design"),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"HLD",src:n(4267).A,width:"2838",height:"1040"})),(0,o.yg)("p",null,"At a high level, the following sequence details the architecture."),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Raccoon accepts events through one of the supported protocols."),(0,o.yg)("li",{parentName:"ul"},"The events are deserialized using the correct deserializer and then forwarded to the buffered channel."),(0,o.yg)("li",{parentName:"ul"},"A pool of worker go routines works off the buffered channel"),(0,o.yg)("li",{parentName:"ul"},"Each worker iterates over the events' batch, determines the topic based on the type and serializes the bytes to the Producer synchronously.")),(0,o.yg)("p",null,"Note: The internals of each of the components like channel size, buffer sizes, publisher properties etc., are configurable enabling Raccoon to be provisioned according to the system/event characteristics and load."),(0,o.yg)("h2",{id:"connections"},"Connections"),(0,o.yg)("h3",{id:"websockets"},"Websockets"),(0,o.yg)("p",null,"Raccoon supports long-running persistent WebSocket connections with the client. Once a client makes an HTTP request with a WebSocket upgrade header, raccoon upgrades the HTTP request to a WebSocket connection end of which a persistent connection is established with the client."),(0,o.yg)("p",null,"The following sequence outlines the connection handling by Raccoon:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Clients make websocket connections to Raccoon by performing a http GET API call, with headers to upgrade to websocket."),(0,o.yg)("li",{parentName:"ul"},"Raccoon uses ",(0,o.yg)("a",{parentName:"li",href:"https://github.com/gorilla/websocket"},"gorilla websocket")," handlers and for each websocket connection the handlers spawn a goroutine to handle incoming requests."),(0,o.yg)("li",{parentName:"ul"},"After the websocket connection has been established, clients can send the events."),(0,o.yg)("li",{parentName:"ul"},"Construct connection identifier from the request header. The identifier is constructed from the value of ",(0,o.yg)("inlineCode",{parentName:"li"},"SERVER_WEBSOCKET_CONN_ID_HEADER")," header. For example, Raccoon is configured with ",(0,o.yg)("inlineCode",{parentName:"li"},"SERVER_WEBSOCKET_CONN_ID_HEADER=X-User-ID"),". Raccoon will check the value of X-User-ID header and make it an identifier. Raccoon then uses this identifier to check if there is already an existing connection with the same identifier. If the same connection already exists, Raccoon will disconnect the connection with an appropriate error message as a response proto.",(0,o.yg)("ul",{parentName:"li"},(0,o.yg)("li",{parentName:"ul"},"Optionally, you can also configure ",(0,o.yg)("inlineCode",{parentName:"li"},"SERVER_WEBSOCKET_CONN_GROUP_HEADER")," to support multi-tenancy. For example, you want to use an instance of Raccoon with multiple mobile clients. You can configure raccoon with ",(0,o.yg)("inlineCode",{parentName:"li"},"SERVER_WEBSOCKET_CONN_GROUP_HEADER=X-Mobile-Client"),". Then, Raccoon will use the value of X-Mobile-Client along with X-User-ID as identifier. The uniqueness becomes the combination of X-User-ID value with X-Mobile-Client value. This way, Raccoon can maintain the same X-User-ID within different X-Mobile-Client."))),(0,o.yg)("li",{parentName:"ul"},"Verify if the total connections have reached the configured limit based on ",(0,o.yg)("inlineCode",{parentName:"li"},"SERVER_WEBSOCKET_MAX_CONN")," configuration. On reaching the max connections, Raccoon disconnects the connection with an appropriate error message as a response proto."),(0,o.yg)("li",{parentName:"ul"},"Upgrade the connection and persist the identifier."),(0,o.yg)("li",{parentName:"ul"},"Add ping/pong handlers on this connection, read timeout deadline. More about these handlers in the following sections"),(0,o.yg)("li",{parentName:"ul"},"At this point, the connection is completely upgraded and Raccoon is ready to accept SendEventRequest. The handler handles each SendEventRequest by sending it to the events-channel. The events can be published by the publisher either synchronously or asynchronous based on the configuration."),(0,o.yg)("li",{parentName:"ul"},"When the connection is closed. Raccoon clean up the connection along with the identifier. The same identifier then can be reused on the upcoming connection.")),(0,o.yg)("h3",{id:"rest"},"REST"),(0,o.yg)("p",null,"Client connects to the server with the same endpoint but with POST HTTP method. As it is a rest endpoint each request is uniquely handled."),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Connection identifier is constructed from the values of ",(0,o.yg)("inlineCode",{parentName:"li"},"SERVER_WEBSOCKET_CONN_ID_HEADER")," and ",(0,o.yg)("inlineCode",{parentName:"li"},"SERVER_WEBSOCKET_CONN_GROUP_HEADER")," header here too.")),(0,o.yg)("h3",{id:"grpc"},"gRPC"),(0,o.yg)("p",null,"It is recommended to generate the gRPC client for Raccoon's ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/raystack/proton/blob/main/raystack/raccoon/EventService.proto"},"EventService")," and use that client to do gRPC request. Currently only unary requests are supported."),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Client's ",(0,o.yg)("inlineCode",{parentName:"li"},"SendEvent")," method is called to send the event."),(0,o.yg)("li",{parentName:"ul"},"Connection identifier is constructed from the values of ",(0,o.yg)("inlineCode",{parentName:"li"},"SERVER_WEBSOCKET_CONN_ID_HEADER")," and ",(0,o.yg)("inlineCode",{parentName:"li"},"SERVER_WEBSOCKET_CONN_GROUP_HEADER")," in gRPC metadata.")),(0,o.yg)("p",null,"Clients can send the request anytime as long as the websocket connection is alive whereas with REST and gRPC requests can be sent only once."),(0,o.yg)("h3",{id:"event-delivery-gurantee-at-least-once-for-most-time"},"Event Delivery Gurantee ","(","at-least-once for most time",")"),(0,o.yg)("p",null,"The server for the most times provide at-least-once event delivery guarantee."),(0,o.yg)("p",null,"Event data loss happens in the following scenarios:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},"When the server shuts down, events in-flight in the buffer or those stored in the internal channels are potentially lost. The server performs, on a best-effort basis, to send all the events within a configured shutdown timeout ",(0,o.yg)("inlineCode",{parentName:"p"},"WORKER_BUFFER_FLUSH_TIMEOUT_MS"),". The default time is set to 5000 ms within which it is expected that all the events are sent by then.")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},"When the downstream message queue is facing a downtime"),(0,o.yg)("p",{parentName:"li"},"Every event sent from the client is stored in-memory in the buffered channels ","(","explained in the ",(0,o.yg)("inlineCode",{parentName:"p"},"Acknowledging events")," section",")",". The workers pull the events from this channel and send it to Producer for publishing. The server does not maintain any event persistence. This is a conscious decision to enable a simpler, performant ingestion design for the server. In future: Server can be augmented for zero-data loss or at-least-once guarantees through intermediate event persistence."))),(0,o.yg)("h2",{id:"acknowledging-events"},"Acknowledging events"),(0,o.yg)("p",null,"Event acknowledgements was designed to signify if the events batch is received and sent successfully. This will enable the clients to retry on failed event delivery. Raccoon chooses when to send event acknowledgement based on the configuration parameter ",(0,o.yg)("inlineCode",{parentName:"p"},"EVENT_ACK"),"."),(0,o.yg)("h3",{id:"event_ack--0"},"EVENT_ACK = 0"),(0,o.yg)("p",null,"Raccoon sends the acknowledgments as soon as it receives and deserializes the events successfully using the proto ",(0,o.yg)("inlineCode",{parentName:"p"},"SendEventRequest"),". This configuration is recommended when low latency takes precedence over end to end acknowledgement. The acks are sent even before it is produced to downstream message queue. The following picture depicts the sequence of the event ack."),(0,o.yg)("p",null,(0,o.yg)("img",{src:n(8818).A,width:"4288",height:"423"})),(0,o.yg)("p",null,"Pros:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Performant as it does not wait for producer/network round trip for each batch of events.")),(0,o.yg)("p",null,"Cons:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Potential data-loss and the clients do not get a chance to retry/resend the events. The possibility of data-loss occurs when the downstream message queue is experiencing downtime.")),(0,o.yg)("h3",{id:"event_ack--1"},"EVENT_ACK = 1"),(0,o.yg)("p",null,"Raccoon sends the acknowledgments after the events are acknowledged successfully from the downstream message queue. This configuration is recommended when reliable end-to-end acknowledgements are required. Here the underlying publisher acknowledgement is leveraged."),(0,o.yg)("p",null,(0,o.yg)("img",{src:n(7407).A,width:"4290",height:"423"})),(0,o.yg)("p",null,"Pros:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Minimal data loss, clients can retry/resend events in case of downtime/broker failures.")),(0,o.yg)("p",null,"Cons:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Increased end to end latency as clients need to wait for the event to be published.")),(0,o.yg)("p",null,"Considering that kafka is set up in a clustered, cross-region, cross-zone environment, the chances of it going down are  unlikely. In case if it does, the amount of events lost is negligible considering it is a streaming system and is expected to forward millions of events/sec."),(0,o.yg)("p",null,"PubSub and Kinesis offer strong SLAs (>=99.95% and >=99.9%) so they are least likey to be unavailable. However, you may hit rate limits for these services, so we advise that you provision your infrastructure sufficiently to avoid it. In case a rate-limit is hit, Raccoon will report the message as undelivered."),(0,o.yg)("p",null,"When an SendEventRequest is sent to Raccoon over any connection be it Websocket/HTTP/gRPC a corresponding response is sent by the server indicating whether the event was consumed successfully or not."),(0,o.yg)("h2",{id:"supported-protocols-and-data-formats"},"Supported Protocols and Data formats"),(0,o.yg)("table",null,(0,o.yg)("thead",{parentName:"table"},(0,o.yg)("tr",{parentName:"thead"},(0,o.yg)("th",{parentName:"tr",align:"center"},"Protocol"),(0,o.yg)("th",{parentName:"tr",align:"center"},"Data Format"),(0,o.yg)("th",{parentName:"tr",align:"center"},"Version"))),(0,o.yg)("tbody",{parentName:"table"},(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:"center"},"WebSocket"),(0,o.yg)("td",{parentName:"tr",align:"center"},"Protobufs"),(0,o.yg)("td",{parentName:"tr",align:"center"},"v0.1.0")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:"center"},"WebSocket"),(0,o.yg)("td",{parentName:"tr",align:"center"},"JSON"),(0,o.yg)("td",{parentName:"tr",align:"center"},"v0.1.2")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:"center"},"REST API"),(0,o.yg)("td",{parentName:"tr",align:"center"},"JSON"),(0,o.yg)("td",{parentName:"tr",align:"center"},"v0.1.2")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:"center"},"REST API"),(0,o.yg)("td",{parentName:"tr",align:"center"},"Protobufs"),(0,o.yg)("td",{parentName:"tr",align:"center"},"v0.1.2")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:"center"},"gRPC"),(0,o.yg)("td",{parentName:"tr",align:"center"},"Protobufs"),(0,o.yg)("td",{parentName:"tr",align:"center"},"v0.1.2")))),(0,o.yg)("h2",{id:"request-and-response-models"},"Request and Response Models"),(0,o.yg)("h3",{id:"protobufs"},"Protobufs"),(0,o.yg)("p",null,"When an ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/raystack/proton/blob/main/raystack/raccoon/v1beta1/raccoon.proto"},"SendEventRequest")," proto below containing events are sent over the wire"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-protobuf"},"message SendEventRequest {\n  //unique guid generated by the client for this request\n  string req_guid = 1;\n  // time probably when the client sent it\n  google.protobuf.Timestamp sent_time = 2;\n  // actual events\n  repeated Event events = 3;\n}\n")),(0,o.yg)("p",null,"a corresponding ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/raystack/proton/blob/main/raystack/raccoon/v1beta1/raccoon.proto"},"SendEventResponse")," is sent by the server."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-protobuf"},"message SendEventResponse {\n  Status status = 1;\n  Code code = 2;\n      /* time when the response is generated */\n  int64 sent_time = 3;\n      /* failure reasons if any */\n  string reason = 4;\n      /* Usually detailing the success/failures */\n  map<string, string> data = 5;\n}\n")),(0,o.yg)("h3",{id:"json"},"JSON"),(0,o.yg)("p",null,"When a JSON event like the one mentioned below is sent a corresponding JSON response is sent by the server."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Request")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "req_guid": "1234abcd",\n  "sent_time": {\n    "seconds": 1638154927,\n    "nanos": 376499000\n  },\n  "events": [\n    {\n      "eventBytes": "Cg4KCHNlcnZpY2UxEgJBMRACIAEyiQEKJDczZTU3ZDlhLTAzMjQtNDI3Yy1hYTc5LWE4MzJjMWZkY2U5ZiISCcix9QzhsChAEekGEi1cMlNAKgwKAmlkEgJpZBjazUsyFwoDaU9zEgQxMi4zGgVBcHBsZSIDaTEwOiYKJDczZTU3ZDlhLTAzMjQtNDI3Yy1hYTc5LWE4MzJjMWZkY2U5Zg==",\n      "type": "booking"\n    }\n  ]\n}\n')),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Response")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "status": 1,\n  "code": 1,\n  "sent_time": 1638155915,\n  "data": {\n    "req_guid": "1234abcd"\n  }\n}\n')),(0,o.yg)("h3",{id:"event-distribution"},"Event Distribution"),(0,o.yg)("p",null,"Event distribution works by finding the type for each event in the batch and sending them to appropriate message queue topic. The topic name is determined by the following code"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-go"},'topic := strings.Replace(p.topicFormat, "%s", event.Type, 1)\n')),(0,o.yg)("p",null,"where:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"topicFormat")," - is the pattern configured via ",(0,o.yg)("inlineCode",{parentName:"li"},"EVENT_DISTRIBUTION_PUBLISHER_PATTERN")," "),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"type")," - is the type set by the client on the Event")),(0,o.yg)("p",null,"For eg. setting the"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"EVENT_DISTRIBUTION_PUBLISHER_PATTERN=topic-%s-log\n")),(0,o.yg)("p",null,"and a type such as ",(0,o.yg)("inlineCode",{parentName:"p"},"type=viewed")," in the ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/raystack/proton/blob/main/raystack/raccoon/v1beta1/raccoon.proto"},"event")," format"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-protobuf"},"message Event {\n  /*\n  `eventBytes` is where you put bytes serialized event.\n  */\n  bytes eventBytes = 1;\n  /*\n  `type` denotes an event type that the producer of this proto message may set.\n  It is currently used by raccoon to distribute events to respective message queue topics. However the\n  users of this proto can use this type to set strings which can be processed in their\n  ingestion systems to distribute or perform other functions.\n  */\n  string type = 2;\n }\n")),(0,o.yg)("p",null,"will have the event sent to a topic like"),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"topic-viewed-log")),(0,o.yg)("p",null,"The event distribution does not depend on any partition logic. So events can be randomly distributed to any available partition."),(0,o.yg)("h3",{id:"event-deserialization"},"Event Deserialization"),(0,o.yg)("p",null,"The top level wrapper ",(0,o.yg)("inlineCode",{parentName:"p"},"SendEventRequest")," is deserialized which provides a list of events of type ",(0,o.yg)("inlineCode",{parentName:"p"},"Event")," proto. This event wrapper composes of serialized bytes, which is the actual event, set in the field ",(0,o.yg)("inlineCode",{parentName:"p"},"bytes")," inside the ",(0,o.yg)("inlineCode",{parentName:"p"},"Event")," proto. Raccoon does not open this underlying bytes. The deserialization is used to unwrap the event type and determine the topic that the ",(0,o.yg)("inlineCode",{parentName:"p"},"eventBytes")," ","(","an event",")"," need to be sent to."),(0,o.yg)("h3",{id:"channels"},"Channels"),(0,o.yg)("p",null,"Buffered Channels are used to store the incoming events' batch. The channel sizes can be configured based on the load & capacity."),(0,o.yg)("h3",{id:"keeping-connections-alive"},"Keeping connections alive"),(0,o.yg)("p",null,"The server ensures that the connections are recyclable. It adopts mechanisms to check connection time idleness. The handlers ping clients very 30 seconds ","(","configurable",")",". If the client does not respond within a stipulated time the connection is marked as corrupt. Every subsequent read/write message there after on this connection fails. Raccoon removes the connections post this. Clients can also ping the server while the server responds with pongs to these pings. Clients can programmatically reconnect on failed or corrupt server connections."),(0,o.yg)("h2",{id:"components"},"Components"),(0,o.yg)("h3",{id:"producer"},"Producer"),(0,o.yg)("p",null,"Raccoon supports a number of destination event storage systems. Following is a list of currently supported systems, along with their status. "),(0,o.yg)("table",null,(0,o.yg)("thead",{parentName:"table"},(0,o.yg)("tr",{parentName:"thead"},(0,o.yg)("th",{parentName:"tr",align:null},"Name"),(0,o.yg)("th",{parentName:"tr",align:null},"Version"),(0,o.yg)("th",{parentName:"tr",align:null},"Status"))),(0,o.yg)("tbody",{parentName:"table"},(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"Apache Kafka"),(0,o.yg)("td",{parentName:"tr",align:null},"v0.1.0"),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"STABLE"))),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"Google Cloud PubSub"),(0,o.yg)("td",{parentName:"tr",align:null},"v0.2.3"),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"ALPHA"))),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"AWS Kinesis Data Streams"),(0,o.yg)("td",{parentName:"tr",align:null},"v0.2.5"),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"ALPHA"))))),(0,o.yg)("h4",{id:"apache-kafka"},"Apache Kafka"),(0,o.yg)("p",null,"Raccoon uses ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/confluentinc/confluent-kafka-go"},"confluent go kafka")," as the producer client to publish events. Publishing events are light weight and relies on kafka producer's retries. Confluent internally uses librdkafka which produces events asynchronously. Application writes messages using a functional based producer API"),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"Produce(message, deliveryChannel)")," -- ",(0,o.yg)("inlineCode",{parentName:"p"},"deliveryChannel")," is where the delivery reports or acknowledgements are received."),(0,o.yg)("p",null,"Raccoon internally checks for these delivery reports before pulling the next batch of events. On failed deliveries the appropriate metrics are updated. This mechanism makes the events delivery synchronous and a reliable events delivery."),(0,o.yg)("h4",{id:"google-cloud-pubsub"},"Google Cloud PubSub"),(0,o.yg)("p",null,"Raccoon uses ",(0,o.yg)("a",{parentName:"p",href:"https://pkg.go.dev/cloud.google.com/go/pubsub"},"cloud.google.com/go/pubsub")," as the producer client for publishing events to Google Cloud PubSub."),(0,o.yg)("p",null,"The Google Cloud PubSub SDK internally buffers messages in batches before sending them downstream. You can control this buffering behaviour by tuning the following env variables:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"/raccoon/reference/configurations#publisher_pubsub_publish_count_threshold"},(0,o.yg)("inlineCode",{parentName:"a"},"PUBLISHER_PUBSUB_PUBLISH_COUNT_THRESHOLD"))),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"/raccoon/reference/configurations#publisher_pubsub_publish_byte_threshold"},(0,o.yg)("inlineCode",{parentName:"a"},"PUBLISHER_PUBSUB_PUBLISH_BYTE_THRESHOLD"))),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"/raccoon/reference/configurations#publisher_pubsub_publish_delay_threshold_ms"},(0,o.yg)("inlineCode",{parentName:"a"},"PUBLISHER_PUBSUB_PUBLISH_DELAY_THRESHOLD_MS")))),(0,o.yg)("p",null,"The defaults for these settings are optimal for near-realtime uses cases."),(0,o.yg)("h4",{id:"aws-kinesis-data-streams"},"AWS Kinesis Data Streams"),(0,o.yg)("p",null,"Raccoon uses ",(0,o.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/kinesis"},"github.com/aws/aws-sdk-go-v2/service/kinesis")," as the producer client for publishing events to AWS Kinesis."),(0,o.yg)("p",null,"In particular, ",(0,o.yg)("inlineCode",{parentName:"p"},"kinesis.PutRecord()")," is used for sending messages downstream. This means that the messages are sent immediately without any buffering at the SDK level. Each message is given a random partition key (using ",(0,o.yg)("inlineCode",{parentName:"p"},"rand.Int31()"),") so that messages are evenly distributed amongst available shards. "),(0,o.yg)("p",null,"In the future, Raccoon may support a more robust partition selection mechanism that has stronger distribution guarantees."),(0,o.yg)("h3",{id:"observability-stack"},"Observability Stack"),(0,o.yg)("p",null,"Raccoon supports ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/statsd/statsd"},"StatsD")," and ",(0,o.yg)("a",{parentName:"p",href:"https://prometheus.io/"},"Prometheus")," as telemetry systems."),(0,o.yg)("h4",{id:"statd"},(0,o.yg)("a",{parentName:"h4",href:"https://github.com/statsd/statsd"},"StatD")),(0,o.yg)("p",null,"A recommended choice for observability stack would be to host ",(0,o.yg)("a",{parentName:"p",href:"https://www.influxdata.com/time-series-platform/telegraf/"},"telegraf")," as the receiver of these measurements and export it to ",(0,o.yg)("a",{parentName:"p",href:"https://www.influxdata.com/get-influxdb/"},"influx")," database for storage, ",(0,o.yg)("a",{parentName:"p",href:"https://grafana.com/"},"grafana")," to build dashboards using Influx as the source."),(0,o.yg)("h4",{id:"prometheus"},(0,o.yg)("a",{parentName:"h4",href:"https://prometheus.io/"},"Prometheus")),(0,o.yg)("p",null,"Prometheus operates on a pull model and comes with it's own time-series database. You don't need any additional components apart from the prometheus to start collecting and storing metrics. ",(0,o.yg)("a",{parentName:"p",href:"https://grafana.com/"},"Grafana")," can be used to build dashboards using Prometheus as a data source."))}d.isMDXComponent=!0},7407:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/raccoon_async-293af9c9ceab1777e1780db272c51fa5.png"},4267:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/raccoon_hld-6627a7d982b7dd633d7214a85eacb31e.png"},8818:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/raccoon_sync-3682a8af8546dae4d1ed0f7026fc1f60.png"}}]);